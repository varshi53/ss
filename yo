EXp 1:

PLAYFAIR:

import java.util.*;
class PlayfairCipher {
    static String encrypt(String text, String key) {
        text = text.replaceAll("J", "I").toUpperCase();
        key = (key + "ABCDEFGHIKLMNOPQRSTUVWXYZ").replaceAll("(.)(?=.*\\1)", "");
        StringBuilder result = new StringBuilder();
        for (int i = 0; i < text.length(); i += 2) {
            char a = text.charAt(i), b = (i + 1 < text.length()) ? text.charAt(i + 1) : 'X';
            int p1 = key.indexOf(a), p2 = key.indexOf(b);
            int r1 = p1 / 5, c1 = p1 % 5, r2 = p2 / 5, c2 = p2 % 5;
            result.append(key.charAt(r1 * 5 + (c1 + 1) % 5)).append(key.charAt(r2 * 5 + (c2 + 1) % 5));
        }
        return result.toString();
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter text: ");
        String text = sc.next().toUpperCase();
        System.out.print("Enter key: ");
        String key = sc.next().toUpperCase();
        System.out.println("Encrypted: " + encrypt(text, key));
        sc.close();
    }
}

...........................


CAESAR :

import java.util.*;
class CaesarCipher {
    public static String shift(String text, int s, boolean encrypt) {
        StringBuilder result = new StringBuilder();
        for (char ch : text.toCharArray()) {
            if (Character.isLetter(ch)) {
                char base = Character.isUpperCase(ch) ? 'A' : 'a';
                ch = (char) ((ch - base + (encrypt ? s : -s + 26)) % 26 + base);
            }
            result.append(ch);
        }
        return result.toString();
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter text: ");
        String text = sc.nextLine();
        System.out.print("Enter shift: ");
        int s = sc.nextInt();
        String encrypted = shift(text, s, true);
        System.out.println("Encrypted: " + encrypted);
        System.out.println("Decrypted: " + shift(encrypted, s, false));
        sc.close();
    }
}


.........................................................................
EXP 2:

RAILFENCE:

public class RailFenceCipher {
    public static String encrypt(String text, int rails) {
        StringBuilder result = new StringBuilder();
        for (int rail = 0; rail < rails; rail++) {
            int pos = rail;
            int step = 2 * (rails - 1); 
            while (pos < text.length()) {
                result.append(text.charAt(pos));
                if (rail == 0 || rail == rails - 1) {
                    pos += step;
                } else {
                    int nextStep = step - 2 * rail;
                    pos += (pos % step == rail) ? nextStep : 2 * rail;
                }
            }
        }
        return result.toString();
    }

    public static String decrypt(String cipher, int rails) {
        char[] result = new char[cipher.length()];
        int pos = 0;
        for (int rail = 0; rail < rails; rail++) {
            int index = rail;
            int step = 2 * (rails - 1);
            while (index < cipher.length()) {
                result[index] = cipher.charAt(pos++);
                if (rail == 0 || rail == rails - 1) {
                    index += step;
                } else {
                    int nextStep = step - 2 * rail;
                    index += (index % step == rail) ? nextStep : 2 * rail;
                }
            }
        }
        return new String(result);
    }
    public static void main(String[] args) {
        String text = "HELLOWORLD";
        int rails = 3;
        String encrypted = encrypt(text, rails);
        System.out.println("Encrypted: " + encrypted);
        String decrypted = decrypt(encrypted, rails);
        System.out.println("Decrypted: " + decrypted);
    }
}

.....................................................


COLUMN 

import java.util.Scanner;
class Main {
public static String decrypt(String ciphertext, int key) {
int length = ciphertext.length();
int numRows = (int) Math.ceil((double) length / key);
char[][] grid = new char[numRows][key];
int index = 0;
for (int j = 0; j < key; j++) {
for (int i = 0; i < numRows; i++) {
if (index < length) {
grid[i][j] = ciphertext.charAt(index++);
}
}
}
StringBuilder plaintext = new StringBuilder();
for (int i = 0; i < numRows; i++) {
for (int j = 0; j < key; j++) {
if (grid[i][j] != 'X') { // Avoid adding padding characters
plaintext.append(grid[i][j]);
}
}
}
return plaintext.toString();
}
public static void main(String[] args) {
Scanner scanner = new Scanner(System.in);
System.out.print("Enter the ciphertext: ");
String ciphertext = scanner.nextLine();
System.out.print("Enter the number of columns (key): ");
int key = scanner.nextInt();
String decryptedText = decrypt(ciphertext, key);
System.out.println("Decrypted Text: " + decryptedText);
scanner.close();
}
}

.....................................................................................
EXP 3 : DES ALGORITHM 

ðŸ”¹ Steps of DES Algorithm (Easy Explanation)
1ï¸âƒ£ Key Generation:

A 56-bit key is prepared from a 64-bit input key.

16 smaller keys (subkeys) are created.

2ï¸âƒ£ Initial Permutation (IP):

The input data (plaintext) is shuffled using a fixed table.

3ï¸âƒ£ Splitting Data:

The 64-bit input is split into two halves:

Left half (L0)

Right half (R0)

4ï¸âƒ£ 16 Rounds of Processing:

The right half is modified using the left half and a subkey.

This happens 16 times, with different subkeys each time.

5ï¸âƒ£ Final Permutation (IPâ»Â¹):

After all 16 rounds, data is shuffled again using another table.

6ï¸âƒ£ Output:

The final result is ciphertext (encrypted data).

The process is reversed for decryption.

import javax.crypto.*;
class Main {
    public static void main(String[] args) throws Exception {
        Cipher c = Cipher.getInstance("DES");
        SecretKey k = KeyGenerator.getInstance("DES").generateKey();
        byte[] text = "HELLO".getBytes();
        c.init(Cipher.ENCRYPT_MODE, k);
        byte[] enc = c.doFinal(text);
        c.init(Cipher.DECRYPT_MODE, k);
        byte[] dec = c.doFinal(enc);
        System.out.println("Encrypted: " + new String(enc));
        System.out.println("Decrypted: " + new String(dec));
    }
}

.......................................................................................
experiment 4: DIFF HELLMAN 

Diffie-Hellman Key Exchange (Simple Explanation)
Diffie-Hellman (DH) is a cryptographic algorithm used for securely exchanging keys over an insecure channel. It allows two parties (e.g., Alice and Bob) to generate a shared secret key without directly sending it over the network.

How Diffie-Hellman Works (Easy Steps)
1ï¸âƒ£ Choose Public Values

Both parties agree on a large prime number p and a base (primitive root) g.

These values are publicly shared and donâ€™t need to be secret.

2ï¸âƒ£ Generate Private Keys

Each party picks a random private key:

Alice picks a

Bob picks b

3ï¸âƒ£ Compute Public Keys

Alice computes: A = g^a mod p

Bob computes: B = g^b mod p

Both A and B are shared publicly.

4ï¸âƒ£ Compute Shared Secret

Alice computes: S = B^a mod p

Bob computes: S = A^b mod p

Since (g^b)^a mod p = (g^a)^b mod p, both compute the same secret key.

class DiffieHellman {
    public static void main(String[] args) {
        long P = 23, G = 9, a = 4, b = 3;
        long x = (long) Math.pow(G, a) % P, y = (long) Math.pow(G, b) % P;
        System.out.println("Alice's Key: " + (long) Math.pow(y, a) % P);
        System.out.println("Bob's Key: " + (long) Math.pow(x, b) % P);
    }
}

.........................................................................................
experiment 5: SHA

SHA-256 Algorithm (Simple Explanation)
SHA-256 (Secure Hash Algorithm 256-bit) is a cryptographic hashing algorithm that converts any input (text, file, etc.) into a fixed 256-bit (64-character) hash. It is part of the SHA-2 family and is much stronger than MD5.

How SHA-256 Works (Easy Steps)
1ï¸âƒ£ Padding the Message

The message is expanded to a length that is 64 bits less than a multiple of 512.

A 1 bit is added, followed by 0s, until the correct length is reached.

The original length of the message (in bits) is added at the end.

2ï¸âƒ£ Initialize SHA-256 Hash Values

Uses 8 fixed 32-bit values:

ini
Copy code
H0 = 0x6a09e667, H1 = 0xbb67ae85, H2 = 0x3c6ef372, H3 = 0xa54ff53a
H4 = 0x510e527f, H5 = 0x9b05688c, H6 = 0x1f83d9ab, H7 = 0x5be0cd19
3ï¸âƒ£ Process Message in 512-bit Blocks

The message is divided into 512-bit chunks.

Each chunk is processed using 64 rounds of complex bitwise operations and mathematical functions.

64 constant values (K) are used in each round.

4ï¸âƒ£ Update Hash Values

After all rounds, the H0-H7 values are updated and combined to generate the final 256-bit (64-character) hash.


import java.math.BigInteger;
import java.security.*;

class Main {
    public static void main(String[] args) throws NoSuchAlgorithmException {
        MessageDigest md = MessageDigest.getInstance("SHA-256");
        for (String s : new String[]{"JavaTPoint", "HashFunc"})
            System.out.println(s + " : " + String.format("%064x", new BigInteger(1, md.digest(s.getBytes()))));
    }
}


............................................................................................

experiment 6: MD5

MD5 Algorithm (Easy Explanation)
MD5 (Message Digest Algorithm 5) is a hashing algorithm that takes any input (text, file, etc.) and converts it into a fixed 128-bit hash value (like a digital fingerprint). It is mainly used for checking data integrity but is not secure for encryption due to vulnerabilities.

How MD5 Works (Simple Steps)
1ï¸âƒ£ Padding (Adding Extra Bits)

The message is expanded to a length that is 64 bits less than a multiple of 512.

A 1 bit is added, followed by 0s, until the correct length is reached.

2ï¸âƒ£ Appending Message Length

The original length of the message is added at the end in 64-bit format.

3ï¸âƒ£ Initialize MD5 Variables

Four fixed 32-bit values are used:
A = 0x67452301, B = 0xEFCDAB89, C = 0x98BADCFE, D = 0x10325476

4ï¸âƒ£ Processing in Blocks (512 bits each)

The message is broken into 512-bit chunks.

Each chunk goes through 64 rounds of mathematical transformations (bitwise operations, shifts, and additions).

5ï¸âƒ£ Generate Final Hash

After all rounds, A, B, C, and D are combined to produce the final 128-bit hash.


import java.math.BigInteger;
import java.security.*;

class Main {
    public static void main(String[] args) throws NoSuchAlgorithmException {
        MessageDigest md = MessageDigest.getInstance("MD5");
        byte[] hash = md.digest("HashFunc".getBytes());
        System.out.println("HashFunc : " + String.format("%032x", new BigInteger(1, hash)));
    }
}

...............................................................................................

EX 7 : digital signature standard

### **Digital Signature Standard (DSS) - Short Definition**  
The **Digital Signature Standard (DSS)** is a cryptographic standard for **digital signatures**, ensuring **authentication, data integrity, and non-repudiation** in electronic communications. It is based on the **DSA (Digital Signature Algorithm)** and other cryptographic methods like RSA or ECDSA.

---

### **Simple Steps of DSS Algorithm**  

1. **Key Generation**  
   - Generate a private key (signing key).  
   - Derive a public key (verification key).  

2. **Signing Process**  
   - Compute the hash of the message.  
   - Use the private key to sign the hash and create the digital signature.  

3. **Verification Process**  
   - The receiver computes the message hash.  
   - The public key is used to verify the signature against the hash.  
   - If they match, the message is authentic; otherwise, it is rejected.  

---

This ensures **secure authentication** and **data integrity** in digital communications. ðŸš€



import java.security.*;
import java.util.Base64;
public class DigitalSignature {
    public static void main(String[] args) throws Exception {
        KeyPair kp = KeyPairGenerator.getInstance("RSA").generateKeyPair();
        Signature sig = Signature.getInstance("SHA256withRSA");
        sig.initSign(kp.getPrivate());
        sig.update("GEEKSFORGEEKS".getBytes());
        byte[] signature = sig.sign();
        sig.initVerify(kp.getPublic());
        sig.update("GEEKSFORGEEKS".getBytes());
        System.out.println("Signature: " + Base64.getEncoder().encodeToString(signature).substring(0, 20) + "...");
        System.out.println("Verified: " + sig.verify(signature));
    }
}


.................................................................................................




